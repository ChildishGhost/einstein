diff --git a/node_modules/vm2/CHANGELOG.md b/node_modules/vm2/CHANGELOG.md
index 2d3a8e7..2a28da1 100644
--- a/node_modules/vm2/CHANGELOG.md
+++ b/node_modules/vm2/CHANGELOG.md
@@ -1,13 +1,3 @@
-v3.9.19 (2023-05-16)
---------------------
-[fix] Fix resolver issue.
-
-v3.9.18 (2023-05-15)
---------------------
-[fix] Multiple security fixes.
-[new] Add resolver API to create a shared resolver for multiple `NodeVM` instances allowing to cache scripts and increase sandbox startup times.
-[new] Allow to pass a function to `require.context` which is called with the filename allowing to specify the context pre file.
-
 v3.9.17 (2023-04-17)
 --------------------
 [fix] Multiple security fixes.
diff --git a/node_modules/vm2/README.md b/node_modules/vm2/README.md
index c25e063..3eac28c 100644
--- a/node_modules/vm2/README.md
+++ b/node_modules/vm2/README.md
@@ -134,14 +134,14 @@ Unlike `VM`, `NodeVM` allows you to require modules in the same way that you wou
 * `eval` - If set to `false` any calls to `eval` or function constructors (`Function`, `GeneratorFunction`, etc.) will throw an `EvalError` (default: `true`).
 * `wasm` -  If set to `false` any attempt to compile a WebAssembly module will throw a `WebAssembly.CompileError` (default: `true`).
 * `sourceExtensions` - Array of file extensions to treat as source code (default: `['js']`).
-* `require` - `true`, an object or a Resolver to enable `require` method (default: `false`).
+* `require` - `true` or object to enable `require` method (default: `false`).
 * `require.external` - Values can be `true`, an array of allowed external modules, or an object (default: `false`). All paths matching `/node_modules/${any_allowed_external_module}/(?!/node_modules/)` are allowed to be required.
 * `require.external.modules` - Array of allowed external modules. Also supports wildcards, so specifying `['@scope/*-ver-??]`, for instance, will allow using all modules having a name of the form `@scope/something-ver-aa`, `@scope/other-ver-11`, etc. The `*` wildcard does not match path separators.
 * `require.external.transitive` - Boolean which indicates if transitive dependencies of external modules are allowed (default: `false`). **WARNING**: When a module is required transitively, any module is then able to require it normally, even if this was not possible before it was loaded.
 * `require.builtin` - Array of allowed built-in modules, accepts ["\*"] for all (default: none). **WARNING**: "\*" can be dangerous as new built-ins can be added.
 * `require.root` - Restricted path(s) where local modules can be required (default: every path).
 * `require.mock` - Collection of mock modules (both external or built-in).
-* `require.context` - `host` (default) to require modules in the host and proxy them into the sandbox. `sandbox` to load, compile, and require modules in the sandbox. `callback(moduleFilename, ext)` to dynamically choose a context per module. The default will be sandbox is nothing is specified. Except for `events`, built-in modules are always required in the host and proxied into the sandbox.
+* `require.context` - `host` (default) to require modules in the host and proxy them into the sandbox. `sandbox` to load, compile, and require modules in the sandbox. Except for `events`, built-in modules are always required in the host and proxied into the sandbox.
 * `require.import` - An array of modules to be loaded into NodeVM on start.
 * `require.resolve` - An additional lookup function in case a module wasn't found in one of the traditional node lookup paths.
 * `require.customRequire` - Use instead of the `require` function to load modules from the host.
@@ -211,28 +211,6 @@ const script = new VMScript('require("foobar")', {filename: '/data/myvmscript.js
 vm.run(script);
 ```
 
-### Resolver
-
-A resolver can be created via `makeResolverFromLegacyOptions` and be used for multiple `NodeVM` instances allowing to share compiled module code potentially speeding up load times. The first example of `NodeVM` can be rewritten using `makeResolverFromLegacyOptions` as follows.
-
-```js
-const resolver = makeResolverFromLegacyOptions({
-    external: true,
-    builtin: ['fs', 'path'],
-    root: './',
-    mock: {
-        fs: {
-            readFileSync: () => 'Nice try!'
-        }
-    }
-});
-const vm = new NodeVM({
-    console: 'inherit',
-    sandbox: {},
-    require: resolver
-});
-```
-
 ## VMScript
 
 You can increase performance by using precompiled scripts. The precompiled VMScript can be run multiple times. It is important to note that the code is not bound to any VM (context); rather, it is bound before each run, just for that run.
diff --git a/node_modules/vm2/index.d.ts b/node_modules/vm2/index.d.ts
index dfbf62c..ceb1c0d 100644
--- a/node_modules/vm2/index.d.ts
+++ b/node_modules/vm2/index.d.ts
@@ -59,24 +59,6 @@ export class VMFileSystem implements VMFileSystemInterface {
   isSeparator(char: string): boolean;
 }
 
-/**
- * Function that will be called to load a built-in into a vm.
- */
-export type BuiltinLoad = (vm: NodeVM) => any;
-/**
- * Either a function that will be called to load a built-in into a vm or an object with a init method and a load method to load the built-in.
- */
-export type Builtin = BuiltinLoad | {init: (vm: NodeVM)=>void, load: BuiltinLoad};
-/**
- * Require method
- */
-export type HostRequire = (id: string) => any;
-
-/**
- * This callback will be called to specify the context to use "per" module. Defaults to 'sandbox' if no return value provided.
- */
-export type PathContextCallback = (modulePath: string, extensionType: string) => 'host' | 'sandbox';
-
 /**
  *  Require options for a VM
  */
@@ -85,25 +67,24 @@ export interface VMRequire {
    * Array of allowed built-in modules, accepts ["*"] for all. Using "*" increases the attack surface and potential
    * new modules allow to escape the sandbox. (default: none)
    */
-  builtin?: readonly string[];
+  builtin?: string[];
   /*
    * `host` (default) to require modules in host and proxy them to sandbox. `sandbox` to load, compile and
-   * require modules in sandbox or a callback which chooses the context based on the filename.
-   * Built-in modules except `events` always required in host and proxied to sandbox
+   * require modules in sandbox. Built-in modules except `events` always required in host and proxied to sandbox
    */
-  context?: "host" | "sandbox" | PathContextCallback;
+  context?: "host" | "sandbox";
   /** `true`, an array of allowed external modules or an object with external options (default: `false`) */
-  external?: boolean | readonly string[] | { modules: readonly string[], transitive: boolean };
+  external?: boolean | string[] | { modules: string[], transitive: boolean };
   /** Array of modules to be loaded into NodeVM on start. */
-  import?: readonly string[];
+  import?: string[];
   /** Restricted path(s) where local modules can be required (default: every path). */
-  root?: string | readonly string[];
+  root?: string | string[];
   /** Collection of mock modules (both external or built-in). */
   mock?: any;
   /* An additional lookup function in case a module wasn't found in one of the traditional node lookup paths. */
   resolve?: (moduleName: string, parentDirname: string) => string | { path: string, module?: string } | undefined;
   /** Custom require to require host and built-in modules. */
-  customRequire?: HostRequire;
+  customRequire?: (id: string) => any;
   /** Load modules in strict mode. (default: true) */
   strict?: boolean;
   /** FileSystem to load files from */
@@ -116,19 +97,6 @@ export interface VMRequire {
  */
 export type CompilerFunction = (code: string, filename: string) => string;
 
-export abstract class Resolver {
-  private constructor(fs: VMFileSystemInterface, globalPaths: readonly string[], builtins: Map<string, Builtin>);
-}
-
-/**
- * Create a resolver as normal `NodeVM` does given `VMRequire` options.
- *
- * @param options The options that would have been given to `NodeVM`.
- * @param override Custom overrides for built-ins.
- * @param compiler Compiler to be used for loaded modules.
- */
-export function makeResolverFromLegacyOptions(options: VMRequire, override?: {[key: string]: Builtin}, compiler?: CompilerFunction): Resolver;
-
 /**
  *  Options for creating a VM
  */
@@ -141,7 +109,7 @@ export interface VMOptions {
   /** VM's global object. */
   sandbox?: any;
   /**
-   * Script timeout in milliseconds. Timeout is only effective on code you run through `run`.
+   * Script timeout in milliseconds.  Timeout is only effective on code you run through `run`.
    * Timeout is NOT effective on any method returned by VM.
    */
   timeout?: number;
@@ -173,7 +141,7 @@ export interface NodeVMOptions extends VMOptions {
   /** `inherit` to enable console, `redirect` to redirect to events, `off` to disable console (default: `inherit`). */
   console?: "inherit" | "redirect" | "off";
   /** `true` or an object to enable `require` options (default: `false`). */
-  require?: boolean | VMRequire | Resolver;
+  require?: boolean | VMRequire;
   /**
    * **WARNING**: This should be disabled. It allows to create a NodeVM form within the sandbox which could return any host module.
    * `true` to enable VMs nesting (default: `false`).
@@ -182,7 +150,7 @@ export interface NodeVMOptions extends VMOptions {
   /** `commonjs` (default) to wrap script into CommonJS wrapper, `none` to retrieve value returned by the script. */
   wrapper?: "commonjs" | "none";
   /** File extensions that the internal module resolver should accept. */
-  sourceExtensions?: readonly string[];
+  sourceExtensions?: string[];
   /**
    * Array of arguments passed to `process.argv`.
    * This object will not be copied and the script can change this object.
@@ -256,8 +224,6 @@ export class NodeVM extends EventEmitter implements VM {
   readonly sandbox: any;
   /** Only here because of implements VM. Does nothing. */
   timeout?: number;
-  /** The resolver used to resolve modules */
-  readonly resolver: Resolver;
   /** Runs the code */
   run(js: string | VMScript, options?: string | { filename?: string, wrapper?: "commonjs" | "none", strict?: boolean }): any;
   /** Runs the code in the specific file */
diff --git a/node_modules/vm2/lib/builtin.js b/node_modules/vm2/lib/builtin.js
deleted file mode 100644
index 499e1f6..0000000
--- a/node_modules/vm2/lib/builtin.js
+++ /dev/null
@@ -1,147 +0,0 @@
-
-const fs = require('fs');
-const nmod = require('module');
-const {EventEmitter} = require('events');
-const util = require('util');
-const {VMScript} = require('./script');
-const {VM} = require('./vm');
-
-const eventsModules = new WeakMap();
-
-function defaultBuiltinLoaderEvents(vm) {
-	return eventsModules.get(vm);
-}
-
-let cacheBufferScript;
-
-function defaultBuiltinLoaderBuffer(vm) {
-	if (!cacheBufferScript) {
-		cacheBufferScript = new VMScript('return buffer=>({Buffer: buffer});', {__proto__: null, filename: 'buffer.js'});
-	}
-	const makeBuffer = vm.run(cacheBufferScript, {__proto__: null, strict: true, wrapper: 'none'});
-	return makeBuffer(Buffer);
-}
-
-let cacheUtilScript;
-
-function defaultBuiltinLoaderUtil(vm) {
-	if (!cacheUtilScript) {
-		cacheUtilScript = new VMScript(`return function inherits(ctor, superCtor) {
-			ctor.super_ = superCtor;
-			Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
-		}`, {__proto__: null, filename: 'util.js'});
-	}
-	const inherits = vm.run(cacheUtilScript, {__proto__: null, strict: true, wrapper: 'none'});
-	const copy = Object.assign({}, util);
-	copy.inherits = inherits;
-	return vm.readonly(copy);
-}
-
-const BUILTIN_MODULES = (nmod.builtinModules || Object.getOwnPropertyNames(process.binding('natives'))).filter(s=>!s.startsWith('internal/'));
-
-let EventEmitterReferencingAsyncResourceClass = null;
-if (EventEmitter.EventEmitterAsyncResource) {
-	// eslint-disable-next-line global-require
-	const {AsyncResource} = require('async_hooks');
-	const kEventEmitter = Symbol('kEventEmitter');
-	class EventEmitterReferencingAsyncResource extends AsyncResource {
-		constructor(ee, type, options) {
-			super(type, options);
-			this[kEventEmitter] = ee;
-		}
-		get eventEmitter() {
-			return this[kEventEmitter];
-		}
-	}
-	EventEmitterReferencingAsyncResourceClass = EventEmitterReferencingAsyncResource;
-}
-
-let cacheEventsScript;
-
-const SPECIAL_MODULES = {
-	events: {
-		init(vm) {
-			if (!cacheEventsScript) {
-				const eventsSource = fs.readFileSync(`${__dirname}/events.js`, 'utf8');
-				cacheEventsScript = new VMScript(`(function (fromhost) { const module = {}; module.exports={};{ ${eventsSource}
-	} return module.exports;})`, {filename: 'events.js'});
-			}
-			const closure = VM.prototype.run.call(vm, cacheEventsScript);
-			const eventsInstance = closure(vm.readonly({
-				kErrorMonitor: EventEmitter.errorMonitor,
-				once: EventEmitter.once,
-				on: EventEmitter.on,
-				getEventListeners: EventEmitter.getEventListeners,
-				EventEmitterReferencingAsyncResource: EventEmitterReferencingAsyncResourceClass
-			}));
-			eventsModules.set(vm, eventsInstance);
-			vm._addProtoMapping(EventEmitter.prototype, eventsInstance.EventEmitter.prototype);
-		},
-		load: defaultBuiltinLoaderEvents
-	},
-	buffer: defaultBuiltinLoaderBuffer,
-	util: defaultBuiltinLoaderUtil
-};
-
-function addDefaultBuiltin(builtins, key, hostRequire) {
-	if (builtins.has(key)) return;
-	const special = SPECIAL_MODULES[key];
-	builtins.set(key, special ? special : vm => vm.readonly(hostRequire(key)));
-}
-
-
-function makeBuiltinsFromLegacyOptions(builtins, hostRequire, mocks, overrides) {
-	const res = new Map();
-	if (mocks) {
-		const keys = Object.getOwnPropertyNames(mocks);
-		for (let i = 0; i < keys.length; i++) {
-			const key = keys[i];
-			res.set(key, (tvm) => tvm.readonly(mocks[key]));
-		}
-	}
-	if (overrides) {
-		const keys = Object.getOwnPropertyNames(overrides);
-		for (let i = 0; i < keys.length; i++) {
-			const key = keys[i];
-			res.set(key, overrides[key]);
-		}
-	}
-	if (Array.isArray(builtins)) {
-		const def = builtins.indexOf('*') >= 0;
-		if (def) {
-			for (let i = 0; i < BUILTIN_MODULES.length; i++) {
-				const name = BUILTIN_MODULES[i];
-				if (builtins.indexOf(`-${name}`) === -1) {
-					addDefaultBuiltin(res, name, hostRequire);
-				}
-			}
-		} else {
-			for (let i = 0; i < BUILTIN_MODULES.length; i++) {
-				const name = BUILTIN_MODULES[i];
-				if (builtins.indexOf(name) !== -1) {
-					addDefaultBuiltin(res, name, hostRequire);
-				}
-			}
-		}
-	} else if (builtins) {
-		for (let i = 0; i < BUILTIN_MODULES.length; i++) {
-			const name = BUILTIN_MODULES[i];
-			if (builtins[name]) {
-				addDefaultBuiltin(res, name, hostRequire);
-			}
-		}
-	}
-	return res;
-}
-
-function makeBuiltins(builtins, hostRequire) {
-	const res = new Map();
-	for (let i = 0; i < builtins.length; i++) {
-		const name = builtins[i];
-		addDefaultBuiltin(res, name, hostRequire);
-	}
-	return res;
-}
-
-exports.makeBuiltinsFromLegacyOptions = makeBuiltinsFromLegacyOptions;
-exports.makeBuiltins = makeBuiltins;
diff --git a/node_modules/vm2/lib/main.js b/node_modules/vm2/lib/main.js
index 15e5163..de5ffc9 100644
--- a/node_modules/vm2/lib/main.js
+++ b/node_modules/vm2/lib/main.js
@@ -15,17 +15,9 @@ const {
 const {
 	VMFileSystem
 } = require('./filesystem');
-const {
-	Resolver
-} = require('./resolver');
-const {
-	makeResolverFromLegacyOptions
-} = require('./resolver-compat');
 
 exports.VMError = VMError;
 exports.VMScript = VMScript;
 exports.NodeVM = NodeVM;
 exports.VM = VM;
 exports.VMFileSystem = VMFileSystem;
-exports.Resolver = Resolver;
-exports.makeResolverFromLegacyOptions = makeResolverFromLegacyOptions;
diff --git a/node_modules/vm2/lib/nodevm.js b/node_modules/vm2/lib/nodevm.js
index d666c70..19986be 100644
--- a/node_modules/vm2/lib/nodevm.js
+++ b/node_modules/vm2/lib/nodevm.js
@@ -17,17 +17,6 @@
  * @return {*} The required module object.
  */
 
-/**
- * This callback will be called to specify the context to use "per" module. Defaults to 'sandbox' if no return value provided.
- *
- * NOTE: many interoperating modules must live in the same context.
- *
- * @callback pathContextCallback
- * @param {string} modulePath - The full path to the module filename being requested.
- * @param {string} extensionType - The module type (node = native, js = cjs/esm module)
- * @return {("host"|"sandbox")} The context for this module.
- */
-
 const fs = require('fs');
 const pa = require('path');
 const {
@@ -49,9 +38,8 @@ const {
 	VM
 } = require('./vm');
 const {
-	makeResolverFromLegacyOptions
+	resolverFromOptions
 } = require('./resolver-compat');
-const { Resolver } = require('./resolver');
 
 const objectDefineProperty = Object.defineProperty;
 const objectDefineProperties = Object.defineProperties;
@@ -98,36 +86,6 @@ const NESTING_OVERRIDE = Object.freeze({
 	vm2: vm2NestingLoader
 });
 
-function makeCustomExtensions(vm, resolver, sourceExtensions) {
-	const extensions = { __proto__: null };
-	const loadJS = resolver.makeExtensionHandler(vm, 'loadJS');
-
-	for (let i = 0; i < sourceExtensions.length; i++) {
-		extensions['.' + sourceExtensions[i]] = loadJS;
-	}
-
-	if (!extensions['.json']) extensions['.json'] = resolver.makeExtensionHandler(vm, 'loadJSON');
-	if (!extensions['.node']) extensions['.node'] = resolver.makeExtensionHandler(vm, 'loadNode');
-	return extensions;
-}
-
-function makeSafePaths(unsafePaths) {
-	if (unsafePaths === undefined) return undefined;
-	if (!Array.isArray(unsafePaths)) return true;
-	const paths = [...unsafePaths];
-	if (paths.some(path => typeof path !== 'string')) return true;
-	return paths;
-}
-
-function makeSafeOptions(unsafeOptions) {
-	if (unsafeOptions === undefined || unsafeOptions == null) return unsafeOptions;
-	if (typeof unsafeOptions !== 'object' && typeof unsafeOptions !== 'function') return unsafeOptions;
-	return {
-		unsafeOptions,
-		paths: makeSafePaths(unsafeOptions.paths)
-	};
-}
-
 /**
  * Event caused by a <code>console.debug</code> call if <code>options.console="redirect"</code> is specified.
  *
@@ -210,7 +168,7 @@ class NodeVM extends VM {
 	 * Only available for node v10+.
 	 * @param {("inherit"|"redirect"|"off")} [options.console="inherit"] - Sets the behavior of the console in the sandbox.
 	 * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.
-	 * @param {Object|boolean|Resolver} [options.require=false] - Allow require inside the sandbox.
+	 * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.
 	 * @param {(boolean|string[]|Object)} [options.require.external=false] - <b>WARNING: When allowing require the option <code>options.require.root</code>
 	 * should be set to restrict the script from requiring any module. Values can be true, an array of allowed external modules or an object.
 	 * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??],
@@ -219,16 +177,14 @@ class NodeVM extends VM {
 	 * @param {string[]} [options.require.builtin=[]] - Array of allowed built-in modules, accepts ["*"] for all.
 	 * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.
 	 * @param {Object} [options.require.mock] - Collection of mock modules (both external or built-in).
-	 * @param {("host"|"sandbox"|pathContextCallback)} [options.require.context="host"] -
-	 * <code>host</code> to require modules in host and proxy them to sandbox.
+	 * @param {("host"|"sandbox")} [options.require.context="host"] - <code>host</code> to require modules in host and proxy them to sandbox.
 	 * <code>sandbox</code> to load, compile and require modules in sandbox.
-	 * <code>pathContext(modulePath, ext)</code> to choose a mode per module (full path provided).
 	 * Builtin modules except <code>events</code> always required in host and proxied to sandbox.
 	 * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.
 	 * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't
 	 * found in one of the traditional node lookup paths.
 	 * @param {customRequire} [options.require.customRequire=require] - Custom require to require host and built-in modules.
-	 * @param {boolean} [options.require.strict=true] - Load required modules in strict mode.
+	 * @param {boolean} [option.require.strict=true] - Load required modules in strict mode.
 	 * @param {boolean} [options.nesting=false] -
 	 * <b>WARNING: Allowing this is a security risk as scripts can create a NodeVM which can require any host module.</b>
 	 * Allow nesting of VMs.
@@ -265,9 +221,6 @@ class NodeVM extends VM {
 
 		super({__proto__: null, compiler: compiler, eval: allowEval, wasm});
 
-		const customResolver = requireOpts instanceof Resolver;
-		const resolver = customResolver ? requireOpts : makeResolverFromLegacyOptions(requireOpts, nesting && NESTING_OVERRIDE, this._compiler);
-
 		// This is only here for backwards compatibility.
 		objectDefineProperty(this, 'options', {__proto__: null, value: {
 			console: consoleType,
@@ -278,18 +231,34 @@ class NodeVM extends VM {
 			strict
 		}});
 
-		objectDefineProperty(this, 'resolver', {__proto__: null, value: resolver, enumerable: true});
+		const resolver = resolverFromOptions(this, requireOpts, nesting && NESTING_OVERRIDE, this._compiler);
+
+		objectDefineProperty(this, '_resolver', {__proto__: null, value: resolver});
 
 		if (!cacheSandboxScript) {
-			cacheSandboxScript = compileScript(`${__dirname}/setup-node-sandbox.js`,
-				`(function (host, data) { ${fs.readFileSync(`${__dirname}/setup-node-sandbox.js`, 'utf8')}\n})`);
+			cacheSandboxScript = compileScript(`${__dirname}/${VM2_LIB_PATH || ''}setup-node-sandbox.js`,
+				`(function (host, data) { ${fs.readFileSync(`${__dirname}/${VM2_LIB_PATH || ''}setup-node-sandbox.js`, 'utf8')}\n})`);
 		}
 
 		const closure = this._runScript(cacheSandboxScript);
 
-		const extensions = makeCustomExtensions(this, resolver, sourceExtensions);
+		const extensions = {
+			__proto__: null
+		};
+
+		const loadJS = (mod, filename) => resolver.loadJS(this, mod, filename);
+
+		for (let i = 0; i < sourceExtensions.length; i++) {
+			extensions['.' + sourceExtensions[i]] = loadJS;
+		}
+
+		if (!extensions['.json']) extensions['.json'] = (mod, filename) => resolver.loadJSON(this, mod, filename);
+		if (!extensions['.node']) extensions['.node'] = (mod, filename) => resolver.loadNode(this, mod, filename);
+
 
 		this.readonly(HOST);
+		this.readonly(resolver);
+		this.readonly(this);
 
 		const {
 			Module,
@@ -301,41 +270,9 @@ class NodeVM extends VM {
 			argv,
 			env,
 			console: consoleType,
-			extensions,
-			emitArgs: (event, args) => {
-				if (typeof event !== 'string' && typeof event !== 'symbol') throw new Error('Event is not a string');
-				return this.emit(event, ...args);
-			},
-			globalPaths: [...resolver.globalPaths],
-			getLookupPathsFor: (path) => {
-				if (typeof path !== 'string') return [];
-				return [...resolver.genLookupPaths(path)];
-			},
-			resolve: (mod, id, opt, ext, direct) => {
-				if (typeof id !== 'string') throw new Error('Id is not a string');
-				const extList = Object.getOwnPropertyNames(ext);
-				return resolver.resolve(mod, id, makeSafeOptions(opt), extList, !!direct);
-			},
-			lookupPaths: (mod, id) => {
-				if (typeof id !== 'string') throw new Error('Id is not a string');
-				return [...resolver.lookupPaths(mod, id)];
-			},
-			loadBuiltinModule: (id) => {
-				if (typeof id !== 'string') throw new Error('Id is not a string');
-				return resolver.loadBuiltinModule(this, id);
-			},
-			registerModule: (mod, filename, path, parent, direct) => {
-				return resolver.registerModule(mod, filename, path, parent, direct);
-			},
-			builtinModules: [...resolver.getBuiltinModulesList(this)],
-			dirname: (path) => {
-				if (typeof path !== 'string') return path;
-				return resolver.fs.dirname(path);
-			},
-			basename: (path) => {
-				if (typeof path !== 'string') return path;
-				return resolver.fs.basename(path);
-			}
+			vm: this,
+			resolver,
+			extensions
 		});
 
 		objectDefineProperties(this, {
@@ -355,7 +292,7 @@ class NodeVM extends VM {
 			this.setGlobals(sandbox);
 		}
 
-		if (!customResolver && requireOpts && requireOpts.import) {
+		if (requireOpts && requireOpts.import) {
 			if (Array.isArray(requireOpts.import)) {
 				for (let i = 0, l = requireOpts.import.length; i < l; i++) {
 					this.require(requireOpts.import[i]);
@@ -366,14 +303,6 @@ class NodeVM extends VM {
 		}
 	}
 
-	/**
-	 * @ignore
-	 * @deprecated
-	 */
-	get _resolver() {
-		return this.resolver;
-	}
-
 	/**
 	 * @ignore
 	 * @deprecated Just call the method yourself like <code>method(args);</code>
@@ -402,12 +331,12 @@ class NodeVM extends VM {
 	 * @throws {*} If the module couldn't be found or loading it threw an error.
 	 */
 	require(module) {
-		const path = this.resolver.fs.resolve('.');
+		const path = this._resolver.pathResolve('.');
 		let mod = this._cacheRequireModule;
 		if (!mod || mod.path !== path) {
-			const filename = this.resolver.fs.join(path, '/vm.js');
+			const filename = this._resolver.pathConcat(path, '/vm.js');
 			mod = new (this._Module)(filename, path);
-			this.resolver.registerModule(mod, filename, path, null, false);
+			this._resolver.registerModule(mod, filename, path, null, false);
 			this._cacheRequireModule = mod;
 		}
 		return this._requireImpl(mod, module, true);
@@ -462,19 +391,19 @@ class NodeVM extends VM {
 		if (code instanceof VMScript) {
 			script = strict ? code._compileNodeVMStrict() : code._compileNodeVM();
 			if (!sandboxModule) {
-				const resolvedFilename = this.resolver.fs.resolve(code.filename);
-				dirname = this.resolver.fs.dirname(resolvedFilename);
+				const resolvedFilename = this._resolver.pathResolve(code.filename);
+				dirname = this._resolver.pathDirname(resolvedFilename);
 				sandboxModule = new (this._Module)(resolvedFilename, dirname);
-				this.resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);
+				this._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);
 			}
 		} else {
 			const unresolvedFilename = filename || 'vm.js';
 			if (!sandboxModule) {
 				if (filename) {
-					const resolvedFilename = this.resolver.fs.resolve(filename);
-					dirname = this.resolver.fs.dirname(resolvedFilename);
+					const resolvedFilename = this._resolver.pathResolve(filename);
+					dirname = this._resolver.pathDirname(resolvedFilename);
 					sandboxModule = new (this._Module)(resolvedFilename, dirname);
-					this.resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);
+					this._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);
 				} else {
 					sandboxModule = new (this._Module)(null, null);
 					sandboxModule.id = unresolvedFilename;
@@ -564,7 +493,7 @@ class NodeVM extends VM {
 	}
 }
 
-function vm2NestingLoader(vm) {
+function vm2NestingLoader(resolver, vm, id) {
 	if (!cacheMakeNestingScript) {
 		cacheMakeNestingScript = compileScript('nesting.js', '(vm, nodevm) => ({VM: vm, NodeVM: nodevm})');
 	}
diff --git a/node_modules/vm2/lib/resolver-compat.js b/node_modules/vm2/lib/resolver-compat.js
index 60ff571..ba58bc2 100644
--- a/node_modules/vm2/lib/resolver-compat.js
+++ b/node_modules/vm2/lib/resolver-compat.js
@@ -1,14 +1,20 @@
 'use strict';
 
 // Translate the old options to the new Resolver functionality.
+
+const fs = require('fs');
+const nmod = require('module');
+const {EventEmitter} = require('events');
+const util = require('util');
+
 const {
 	Resolver,
 	DefaultResolver
 } = require('./resolver');
+const {VMScript} = require('./script');
+const {VM} = require('./vm');
 const {VMError} = require('./bridge');
 const {DefaultFileSystem} = require('./filesystem');
-const {makeBuiltinsFromLegacyOptions} = require('./builtin');
-const {jsCompiler} = require('./compiler');
 
 /**
  * Require wrapper to be able to annotate require with webpackIgnore.
@@ -38,66 +44,11 @@ function makeExternalMatcher(obj) {
 	return new RegExp(`[\\\\/]node_modules[\\\\/]${regexString}(?:[\\\\/](?!(?:.*[\\\\/])?node_modules[\\\\/]).*)?$`);
 }
 
-class CustomResolver extends DefaultResolver {
-
-	constructor(fileSystem, globalPaths, builtinModules, rootPaths, pathContext, customResolver, hostRequire, compiler, strict) {
-		super(fileSystem, globalPaths, builtinModules);
-		this.rootPaths = rootPaths;
-		this.pathContext = pathContext;
-		this.customResolver = customResolver;
-		this.hostRequire = hostRequire;
-		this.compiler = compiler;
-		this.strict = strict;
-	}
-
-	isPathAllowed(filename) {
-		return this.rootPaths === undefined || this.rootPaths.some(path => {
-			if (!filename.startsWith(path)) return false;
-			const len = path.length;
-			if (filename.length === len || (len > 0 && this.fs.isSeparator(path[len-1]))) return true;
-			return this.fs.isSeparator(filename[len]);
-		});
-	}
-
-	loadJS(vm, mod, filename) {
-		if (this.pathContext(filename, 'js') !== 'host') return super.loadJS(vm, mod, filename);
-		const m = this.hostRequire(filename);
-		mod.exports = vm.readonly(m);
-	}
-
-	loadNode(vm, mod, filename) {
-		if (this.pathContext(filename, 'node') !== 'host') return super.loadNode(vm, mod, filename);
-		const m = this.hostRequire(filename);
-		mod.exports = vm.readonly(m);
-	}
+class LegacyResolver extends DefaultResolver {
 
-	customResolve(x, path, extList) {
-		if (this.customResolver === undefined) return undefined;
-		const resolved = this.customResolver(x, path);
-		if (!resolved) return undefined;
-		if (typeof resolved === 'string') {
-			return this.loadAsFileOrDirectory(resolved, extList);
-		}
-		const {module=x, path: resolvedPath} = resolved;
-		return this.loadNodeModules(module, [resolvedPath], extList);
-	}
-
-	getCompiler(filename) {
-		return this.compiler;
-	}
-
-	isStrict(filename) {
-		return this.strict;
-	}
-
-}
-
-class LegacyResolver extends CustomResolver {
-
-	constructor(fileSystem, globalPaths, builtinModules, rootPaths, pathContext, customResolver, hostRequire, compiler, strict, externals, allowTransitive) {
-		super(fileSystem, globalPaths, builtinModules, rootPaths, pathContext, customResolver, hostRequire, compiler, strict);
-		this.externals = externals.map(makeExternalMatcher);
-		this.externalCache = externals.map(pattern => new RegExp(makeExternalMatcherRegex(pattern)));
+	constructor(fileSystem, builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler, strict, externals, allowTransitive) {
+		super(fileSystem, builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler, strict);
+		this.externals = externals;
 		this.currMod = undefined;
 		this.trustedMods = new WeakMap();
 		this.allowTransitive = allowTransitive;
@@ -130,21 +81,23 @@ class LegacyResolver extends CustomResolver {
 		});
 	}
 
-	resolveFull(mod, x, options, extList, direct) {
+	resolveFull(mod, x, options, ext, direct) {
 		this.currMod = undefined;
-		if (!direct) return super.resolveFull(mod, x, options, extList, false);
+		if (!direct) return super.resolveFull(mod, x, options, ext, false);
 		const trustedMod = this.trustedMods.get(mod);
-		if (!trustedMod || mod.path !== trustedMod.path) return super.resolveFull(mod, x, options, extList, false);
+		if (!trustedMod || mod.path !== trustedMod.path) return super.resolveFull(mod, x, options, ext, false);
 		const paths = [...mod.paths];
-		if (paths.length !== trustedMod.paths.length) return super.resolveFull(mod, x, options, extList, false);
-		for (let i = 0; i < paths.length; i++) {
-			if (paths[i] !== trustedMod.paths[i]) {
-				return super.resolveFull(mod, x, options, extList, false);
+		if (paths.length === trustedMod.length) {
+			for (let i = 0; i < paths.length; i++) {
+				if (paths[i] !== trustedMod.paths[i]) {
+					return super.resolveFull(mod, x, options, ext, false);
+				}
 			}
 		}
+		const extCopy = Object.assign({__proto__: null}, ext);
 		try {
 			this.currMod = trustedMod;
-			return super.resolveFull(trustedMod, x, options, extList, true);
+			return super.resolveFull(trustedMod, x, undefined, extCopy, true);
 		} finally {
 			this.currMod = undefined;
 		}
@@ -158,43 +111,170 @@ class LegacyResolver extends CustomResolver {
 	}
 
 	loadJS(vm, mod, filename) {
-		if (this.pathContext(filename, 'js') !== 'host') {
+		filename = this.pathResolve(filename);
+		this.checkAccess(mod, filename);
+		if (this.pathContext(filename, 'js') === 'sandbox') {
 			const trustedMod = this.trustedMods.get(mod);
 			const script = this.readScript(filename);
-			vm.run(script, {filename, strict: this.isStrict(filename), module: mod, wrapper: 'none', dirname: trustedMod ? trustedMod.path : mod.path});
+			vm.run(script, {filename, strict: true, module: mod, wrapper: 'none', dirname: trustedMod ? trustedMod.path : mod.path});
 		} else {
 			const m = this.hostRequire(filename);
 			mod.exports = vm.readonly(m);
 		}
 	}
 
-	customResolve(x, path, extList) {
-		if (this.customResolver === undefined) return undefined;
-		if (!(this.pathIsAbsolute(x) || this.pathIsRelative(x))) {
-			if (!this.externalCache.some(regex => regex.test(x))) return undefined;
+}
+
+function defaultBuiltinLoader(resolver, vm, id) {
+	const mod = resolver.hostRequire(id);
+	return vm.readonly(mod);
+}
+
+const eventsModules = new WeakMap();
+
+function defaultBuiltinLoaderEvents(resolver, vm, id) {
+	return eventsModules.get(vm);
+}
+
+let cacheBufferScript;
+
+function defaultBuiltinLoaderBuffer(resolver, vm, id) {
+	if (!cacheBufferScript) {
+		cacheBufferScript = new VMScript('return buffer=>({Buffer: buffer});', {__proto__: null, filename: 'buffer.js'});
+	}
+	const makeBuffer = vm.run(cacheBufferScript, {__proto__: null, strict: true, wrapper: 'none'});
+	return makeBuffer(Buffer);
+}
+
+let cacheUtilScript;
+
+function defaultBuiltinLoaderUtil(resolver, vm, id) {
+	if (!cacheUtilScript) {
+		cacheUtilScript = new VMScript(`return function inherits(ctor, superCtor) {
+			ctor.super_ = superCtor;
+			Object.setPrototypeOf(ctor.prototype, superCtor.prototype);
+		}`, {__proto__: null, filename: 'util.js'});
+	}
+	const inherits = vm.run(cacheUtilScript, {__proto__: null, strict: true, wrapper: 'none'});
+	const copy = Object.assign({}, util);
+	copy.inherits = inherits;
+	return vm.readonly(copy);
+}
+
+const BUILTIN_MODULES = (nmod.builtinModules || Object.getOwnPropertyNames(process.binding('natives'))).filter(s=>!s.startsWith('internal/'));
+
+let EventEmitterReferencingAsyncResourceClass = null;
+if (EventEmitter.EventEmitterAsyncResource) {
+	// eslint-disable-next-line global-require
+	const {AsyncResource} = require('async_hooks');
+	const kEventEmitter = Symbol('kEventEmitter');
+	class EventEmitterReferencingAsyncResource extends AsyncResource {
+		constructor(ee, type, options) {
+			super(type, options);
+			this[kEventEmitter] = ee;
+		}
+		get eventEmitter() {
+			return this[kEventEmitter];
+		}
+	}
+	EventEmitterReferencingAsyncResourceClass = EventEmitterReferencingAsyncResource;
+}
+
+let cacheEventsScript;
+
+const SPECIAL_MODULES = {
+	events(vm) {
+		if (!cacheEventsScript) {
+			const eventsSource = fs.readFileSync(`${__dirname}/${VM2_LIB_PATH || ''}events.js`, 'utf8');
+			cacheEventsScript = new VMScript(`(function (fromhost) { const module = {}; module.exports={};{ ${eventsSource}
+} return module.exports;})`, {filename: 'events.js'});
+		}
+		const closure = VM.prototype.run.call(vm, cacheEventsScript);
+		const eventsInstance = closure(vm.readonly({
+			kErrorMonitor: EventEmitter.errorMonitor,
+			once: EventEmitter.once,
+			on: EventEmitter.on,
+			getEventListeners: EventEmitter.getEventListeners,
+			EventEmitterReferencingAsyncResource: EventEmitterReferencingAsyncResourceClass
+		}));
+		eventsModules.set(vm, eventsInstance);
+		vm._addProtoMapping(EventEmitter.prototype, eventsInstance.EventEmitter.prototype);
+		return defaultBuiltinLoaderEvents;
+	},
+	buffer(vm) {
+		return defaultBuiltinLoaderBuffer;
+	},
+	util(vm) {
+		return defaultBuiltinLoaderUtil;
+	}
+};
+
+function addDefaultBuiltin(builtins, key, vm) {
+	if (builtins[key]) return;
+	const special = SPECIAL_MODULES[key];
+	builtins[key] = special ? special(vm) : defaultBuiltinLoader;
+}
+
+
+function genBuiltinsFromOptions(vm, builtinOpt, mockOpt, override) {
+	const builtins = {__proto__: null};
+	if (mockOpt) {
+		const keys = Object.getOwnPropertyNames(mockOpt);
+		for (let i = 0; i < keys.length; i++) {
+			const key = keys[i];
+			builtins[key] = (resolver, tvm, id) => tvm.readonly(mockOpt[key]);
 		}
-		const resolved = this.customResolver(x, path);
-		if (!resolved) return undefined;
-		if (typeof resolved === 'string') {
-			this.externals.push(new RegExp('^' + escapeRegExp(resolved)));
-			return this.loadAsFileOrDirectory(resolved, extList);
+	}
+	if (override) {
+		const keys = Object.getOwnPropertyNames(override);
+		for (let i = 0; i < keys.length; i++) {
+			const key = keys[i];
+			builtins[key] = override[key];
 		}
-		const {module=x, path: resolvedPath} = resolved;
-		this.externals.push(new RegExp('^' + escapeRegExp(resolvedPath)));
-		return this.loadNodeModules(module, [resolvedPath], extList);
 	}
+	if (Array.isArray(builtinOpt)) {
+		const def = builtinOpt.indexOf('*') >= 0;
+		if (def) {
+			for (let i = 0; i < BUILTIN_MODULES.length; i++) {
+				const name = BUILTIN_MODULES[i];
+				if (builtinOpt.indexOf(`-${name}`) === -1) {
+					addDefaultBuiltin(builtins, name, vm);
+				}
+			}
+		} else {
+			for (let i = 0; i < BUILTIN_MODULES.length; i++) {
+				const name = BUILTIN_MODULES[i];
+				if (builtinOpt.indexOf(name) !== -1) {
+					addDefaultBuiltin(builtins, name, vm);
+				}
+			}
+		}
+	} else if (builtinOpt) {
+		for (let i = 0; i < BUILTIN_MODULES.length; i++) {
+			const name = BUILTIN_MODULES[i];
+			if (builtinOpt[name]) {
+				addDefaultBuiltin(builtins, name, vm);
+			}
+		}
+	}
+	return builtins;
+}
 
+function defaultCustomResolver() {
+	return undefined;
 }
 
 const DEFAULT_FS = new DefaultFileSystem();
 
-const DENY_RESOLVER = new Resolver(DEFAULT_FS, [], new Map());
+const DENY_RESOLVER = new Resolver(DEFAULT_FS, {__proto__: null}, [], id => {
+	throw new VMError(`Access denied to require '${id}'`, 'EDENIED');
+});
 
-function makeResolverFromLegacyOptions(options, override, compiler) {
+function resolverFromOptions(vm, options, override, compiler) {
 	if (!options) {
 		if (!override) return DENY_RESOLVER;
-		const builtins = makeBuiltinsFromLegacyOptions(undefined, defaultRequire, undefined, override);
-		return new Resolver(DEFAULT_FS, [], builtins);
+		const builtins = genBuiltinsFromOptions(vm, undefined, undefined, override);
+		return new Resolver(DEFAULT_FS, builtins, [], defaultRequire);
 	}
 
 	const {
@@ -209,29 +289,62 @@ function makeResolverFromLegacyOptions(options, override, compiler) {
 		fs: fsOpt = DEFAULT_FS,
 	} = options;
 
-	const builtins = makeBuiltinsFromLegacyOptions(builtinOpt, hostRequire, mockOpt, override);
-
-	if (!externalOpt) return new Resolver(fsOpt, [], builtins);
-
-	if (!compiler) compiler = jsCompiler;
-
-	const checkedRootPaths = rootPaths ? (Array.isArray(rootPaths) ? rootPaths : [rootPaths]).map(f => fsOpt.resolve(f)) : undefined;
+	const builtins = genBuiltinsFromOptions(vm, builtinOpt, mockOpt, override);
+
+	if (!externalOpt) return new Resolver(fsOpt, builtins, [], hostRequire);
+
+	let checkPath;
+	if (rootPaths) {
+		const checkedRootPaths = (Array.isArray(rootPaths) ? rootPaths : [rootPaths]).map(f => fsOpt.resolve(f));
+		checkPath = (filename) => {
+			return checkedRootPaths.some(path => {
+				if (!filename.startsWith(path)) return false;
+				const len = path.length;
+				if (filename.length === len || (len > 0 && fsOpt.isSeparator(path[len-1]))) return true;
+				return fsOpt.isSeparator(filename[len]);
+			});
+		};
+	} else {
+		checkPath = () => true;
+	}
 
-	const pathContext = typeof context === 'function' ? context : (() => context);
+	let newCustomResolver = defaultCustomResolver;
+	let externals = undefined;
+	let external = undefined;
+	if (customResolver) {
+		let externalCache;
+		newCustomResolver = (resolver, x, path, extList) => {
+			if (external && !(resolver.pathIsAbsolute(x) || resolver.pathIsRelative(x))) {
+				if (!externalCache) {
+					externalCache = external.map(ext => new RegExp(makeExternalMatcherRegex(ext)));
+				}
+				if (!externalCache.some(regex => regex.test(x))) return undefined;
+			}
+			const resolved = customResolver(x, path);
+			if (!resolved) return undefined;
+			if (typeof resolved === 'string') {
+				if (externals) externals.push(new RegExp('^' + escapeRegExp(resolved)));
+				return resolver.loadAsFileOrDirectory(resolved, extList);
+			}
+			const {module=x, path: resolvedPath} = resolved;
+			if (externals) externals.push(new RegExp('^' + escapeRegExp(resolvedPath)));
+			return resolver.loadNodeModules(module, [resolvedPath], extList);
+		};
+	}
 
 	if (typeof externalOpt !== 'object') {
-		return new CustomResolver(fsOpt, [], builtins, checkedRootPaths, pathContext, customResolver, hostRequire, compiler, strict);
+		return new DefaultResolver(fsOpt, builtins, checkPath, [], () => context, newCustomResolver, hostRequire, compiler, strict);
 	}
 
 	let transitive = false;
-	let external = undefined;
 	if (Array.isArray(externalOpt)) {
 		external = externalOpt;
 	} else {
 		external = externalOpt.modules;
-		transitive = context !== 'host' && externalOpt.transitive;
+		transitive = context === 'sandbox' && externalOpt.transitive;
 	}
-	return new LegacyResolver(fsOpt, [], builtins, checkedRootPaths, pathContext, customResolver, hostRequire, compiler, strict, external, transitive);
+	externals = external.map(makeExternalMatcher);
+	return new LegacyResolver(fsOpt, builtins, checkPath, [], () => context, newCustomResolver, hostRequire, compiler, strict, externals, transitive);
 }
 
-exports.makeResolverFromLegacyOptions = makeResolverFromLegacyOptions;
+exports.resolverFromOptions = resolverFromOptions;
diff --git a/node_modules/vm2/lib/resolver.js b/node_modules/vm2/lib/resolver.js
index fd86aff..22f9061 100644
--- a/node_modules/vm2/lib/resolver.js
+++ b/node_modules/vm2/lib/resolver.js
@@ -6,7 +6,6 @@ const {
 	VMError
 } = require('./bridge');
 const { VMScript } = require('./script');
-const { jsCopmiler } = require('./compiler');
 
 // This should match. Note that '\', '%' are invalid characters
 // 1. name/.*
@@ -22,24 +21,19 @@ function isArrayIndex(key) {
 
 class Resolver {
 
-	constructor(fs, globalPaths, builtins) {
+	constructor(fs, builtinModules, globalPaths, hostRequire) {
 		this.fs = fs;
+		this.builtinModules = builtinModules;
 		this.globalPaths = globalPaths;
-		this.builtins = builtins;
+		this.hostRequire = hostRequire;
 	}
 
 	init(vm) {
 
 	}
 
-	isPathAllowed(path) {
-		return false;
-	}
-
-	checkAccess(mod, filename) {
-		if (!this.isPathAllowed(filename)) {
-			throw new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');
-		}
+	pathResolve(path) {
+		return this.fs.resolve(path);
 	}
 
 	pathIsRelative(path) {
@@ -54,45 +48,31 @@ class Resolver {
 		return path !== '' && (this.fs.isSeparator(path[0]) || this.fs.isAbsolute(path));
 	}
 
+	pathConcat(...paths) {
+		return this.fs.join(...paths);
+	}
+
+	pathBasename(path) {
+		return this.fs.basename(path);
+	}
+
+	pathDirname(path) {
+		return this.fs.dirname(path);
+	}
+
 	lookupPaths(mod, id) {
+		if (typeof id === 'string') throw new Error('Id is not a string');
 		if (this.pathIsRelative(id)) return [mod.path || '.'];
 		return [...mod.paths, ...this.globalPaths];
 	}
 
-	getBuiltinModulesList(vm) {
-		if (this.builtins === undefined) return [];
-		const res = [];
-		this.builtins.forEach((value, key) => {
-			if (typeof value === 'object') value.init(vm);
-			res.push(key);
-		});
-		return res;
+	getBuiltinModulesList() {
+		return Object.getOwnPropertyNames(this.builtinModules);
 	}
 
 	loadBuiltinModule(vm, id) {
-		if (this.builtins === undefined) return undefined;
-		const builtin = this.builtins.get(id);
-		if (!builtin) return undefined;
-		if (typeof builtin === 'function') return builtin(vm);
-		return builtin.load(vm);
-	}
-
-	makeExtensionHandler(vm, name) {
-		return (mod, filename) => {
-			filename = this.fs.resolve(filename);
-			this.checkAccess(mod, filename);
-			this[name](vm, mod, filename);
-		};
-	}
-
-	getExtensions(vm) {
-		return {
-			// eslint-disable-next-line quote-props
-			__proto__: null,
-			'.js': this.makeExtensionHandler(vm, 'loadJS'),
-			'.json': this.makeExtensionHandler(vm, 'loadJSON'),
-			' .node': this.makeExtensionHandler(vm, 'loadNode'),
-		};
+		const handler = this.builtinModules[id];
+		return handler && handler(this, vm, id);
 	}
 
 	loadJS(vm, mod, filename) {
@@ -111,17 +91,19 @@ class Resolver {
 
 	}
 
-	resolve(mod, x, options, extList, direct) {
-		if (x.startsWith('node:') || this.builtins.has(x)) {
+	resolve(mod, x, options, ext, direct) {
+		if (typeof x !== 'string') throw new Error('Id is not a string');
+
+		if (x.startsWith('node:') || this.builtinModules[x]) {
 			// a. return the core module
 			// b. STOP
 			return x;
 		}
 
-		return this.resolveFull(mod, x, options, extList, direct);
+		return this.resolveFull(mod, x, options, ext, direct);
 	}
 
-	resolveFull(mod, x, options, extList, direct) {
+	resolveFull(mod, x, options, ext, direct) {
 		// 7. THROW "not found"
 		throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');
 	}
@@ -134,14 +116,14 @@ class Resolver {
 		const dirs = [];
 		// 4. while I >= 0,
 		while (true) {
-			const name = this.fs.basename(path);
+			const name = this.pathBasename(path);
 			// a. if PARTS[I] = "node_modules" CONTINUE
 			if (name !== 'node_modules') {
 				// b. DIR = path join(PARTS[0 .. I] + "node_modules")
 				// c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR
-				dirs.push(this.fs.join(path, 'node_modules'));
+				dirs.push(this.pathConcat(path, 'node_modules'));
 			}
-			const dir = this.fs.dirname(path);
+			const dir = this.pathDirname(path);
 			if (dir == path) break;
 			// d. let I = I - 1
 			path = dir;
@@ -154,79 +136,96 @@ class Resolver {
 
 }
 
-function pathTestIsDirectory(fs, path) {
-	try {
-		const stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});
-		return stat && stat.isDirectory();
-	} catch (e) {
-		return false;
-	}
-}
+class DefaultResolver extends Resolver {
 
-function pathTestIsFile(fs, path) {
-	try {
-		const stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});
-		return stat && stat.isFile();
-	} catch (e) {
-		return false;
+	constructor(fs, builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler, strict) {
+		super(fs, builtinModules, globalPaths, hostRequire);
+		this.checkPath = checkPath;
+		this.pathContext = pathContext;
+		this.customResolver = customResolver;
+		this.compiler = compiler;
+		this.strict = strict;
+		this.packageCache = {__proto__: null};
+		this.scriptCache = {__proto__: null};
 	}
-}
-
-function readFile(fs, path) {
-	return fs.readFileSync(path, {encoding: 'utf8'});
-}
 
-function readFileWhenExists(fs, path) {
-	return pathTestIsFile(fs, path) ? readFile(fs, path) : undefined;
-}
+	isPathAllowed(path) {
+		return this.checkPath(path);
+	}
 
-class DefaultResolver extends Resolver {
+	pathTestIsDirectory(path) {
+		try {
+			const stat = this.fs.statSync(path, {__proto__: null, throwIfNoEntry: false});
+			return stat && stat.isDirectory();
+		} catch (e) {
+			return false;
+		}
+	}
 
-	constructor(fs, globalPaths, builtins) {
-		super(fs, globalPaths, builtins);
-		this.packageCache = new Map();
-		this.scriptCache = new Map();
+	pathTestIsFile(path) {
+		try {
+			const stat = this.fs.statSync(path, {__proto__: null, throwIfNoEntry: false});
+			return stat && stat.isFile();
+		} catch (e) {
+			return false;
+		}
 	}
 
-	getCompiler(filename) {
-		return jsCopmiler;
+	readFile(path) {
+		return this.fs.readFileSync(path, {encoding: 'utf8'});
 	}
 
-	isStrict(filename) {
-		return true;
+	readFileWhenExists(path) {
+		return this.pathTestIsFile(path) ? this.readFile(path) : undefined;
 	}
 
 	readScript(filename) {
-		let script = this.scriptCache.get(filename);
+		let script = this.scriptCache[filename];
 		if (!script) {
-			script = new VMScript(readFile(this.fs, filename), {filename, compiler: this.getCompiler(filename)});
-			this.scriptCache.set(filename, script);
+			script = new VMScript(this.readFile(filename), {filename, compiler: this.compiler});
+			this.scriptCache[filename] = script;
 		}
 		return script;
 	}
 
+	checkAccess(mod, filename) {
+		if (!this.isPathAllowed(filename)) {
+			throw new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');
+		}
+	}
+
 	loadJS(vm, mod, filename) {
-		const script = this.readScript(filename);
-		vm.run(script, {filename, strict: this.isStrict(filename), module: mod, wrapper: 'none', dirname: mod.path});
+		filename = this.pathResolve(filename);
+		this.checkAccess(mod, filename);
+		if (this.pathContext(filename, 'js') === 'sandbox') {
+			const script = this.readScript(filename);
+			vm.run(script, {filename, strict: this.strict, module: mod, wrapper: 'none', dirname: mod.path});
+		} else {
+			const m = this.hostRequire(filename);
+			mod.exports = vm.readonly(m);
+		}
 	}
 
 	loadJSON(vm, mod, filename) {
-		const json = readFile(this.fs, filename);
+		filename = this.pathResolve(filename);
+		this.checkAccess(mod, filename);
+		const json = this.readFile(filename);
 		mod.exports = vm._jsonParse(json);
 	}
 
 	loadNode(vm, mod, filename) {
-		throw new VMError('Native modules can be required only with context set to \'host\'.');
-	}
-
-	customResolve(x, path, extList) {
-		return undefined;
+		filename = this.pathResolve(filename);
+		this.checkAccess(mod, filename);
+		if (this.pathContext(filename, 'node') === 'sandbox') throw new VMError('Native modules can be required only with context set to \'host\'.');
+		const m = this.hostRequire(filename);
+		mod.exports = vm.readonly(m);
 	}
 
 	// require(X) from module at path Y
-	resolveFull(mod, x, options, extList, direct) {
+	resolveFull(mod, x, options, ext, direct) {
 		// Note: core module handled by caller
 
+		const extList = Object.getOwnPropertyNames(ext);
 		const path = mod.path || '.';
 
 		// 5. LOAD_PACKAGE_SELF(X, dirname(Y))
@@ -257,13 +256,13 @@ class DefaultResolver extends Resolver {
 					for (let i = 0; i < paths.length; i++) {
 						// a. LOAD_AS_FILE(Y + X)
 						// b. LOAD_AS_DIRECTORY(Y + X)
-						f = this.loadAsFileOrDirectory(this.fs.join(paths[i], x), extList);
+						f = this.loadAsFileOrDirectory(this.pathConcat(paths[i], x), extList);
 						if (f) return f;
 					}
 				} else if (paths === undefined) {
 					// a. LOAD_AS_FILE(Y + X)
 					// b. LOAD_AS_DIRECTORY(Y + X)
-					f = this.loadAsFileOrDirectory(this.fs.join(path, x), extList);
+					f = this.loadAsFileOrDirectory(this.pathConcat(path, x), extList);
 					if (f) return f;
 				} else {
 					throw new VMError('Invalid options.paths option.');
@@ -271,7 +270,7 @@ class DefaultResolver extends Resolver {
 			} else {
 				// a. LOAD_AS_FILE(Y + X)
 				// b. LOAD_AS_DIRECTORY(Y + X)
-				f = this.loadAsFileOrDirectory(this.fs.join(path, x), extList);
+				f = this.loadAsFileOrDirectory(this.pathConcat(path, x), extList);
 				if (f) return f;
 			}
 
@@ -310,10 +309,10 @@ class DefaultResolver extends Resolver {
 		f = this.loadNodeModules(x, dirs, extList);
 		if (f) return f;
 
-		f = this.customResolve(x, path, extList);
+		f = this.customResolver(this, x, path, extList);
 		if (f) return f;
 
-		return super.resolveFull(mod, x, options, extList, direct);
+		return super.resolveFull(mod, x, options, ext, direct);
 	}
 
 	loadAsFileOrDirectory(x, extList) {
@@ -325,14 +324,14 @@ class DefaultResolver extends Resolver {
 	}
 
 	tryFile(x) {
-		x = this.fs.resolve(x);
-		return this.isPathAllowed(x) && pathTestIsFile(this.fs, x) ? x : undefined;
+		x = this.pathResolve(x);
+		return this.isPathAllowed(x) && this.pathTestIsFile(x) ? x : undefined;
 	}
 
 	tryWithExtension(x, extList) {
 		for (let i = 0; i < extList.length; i++) {
 			const ext = extList[i];
-			if (ext !== this.fs.basename(ext)) continue;
+			if (ext !== this.pathBasename(ext)) continue;
 			const f = this.tryFile(x + ext);
 			if (f) return f;
 		}
@@ -340,15 +339,15 @@ class DefaultResolver extends Resolver {
 	}
 
 	readPackage(path) {
-		const packagePath = this.fs.resolve(this.fs.join(path, 'package.json'));
+		const packagePath = this.pathResolve(this.pathConcat(path, 'package.json'));
 
-		const cache = this.packageCache.get(packagePath);
+		const cache = this.packageCache[packagePath];
 		if (cache !== undefined) return cache;
 
 		if (!this.isPathAllowed(packagePath)) return undefined;
-		const content = readFileWhenExists(this.fs, packagePath);
+		const content = this.readFileWhenExists(packagePath);
 		if (!content) {
-			this.packageCache.set(packagePath, false);
+			this.packageCache[packagePath] = false;
 			return false;
 		}
 
@@ -368,15 +367,15 @@ class DefaultResolver extends Resolver {
 			imports: parsed.imports,
 			type: parsed.type
 		};
-		this.packageCache.set(packagePath, filtered);
+		this.packageCache[packagePath] = filtered;
 		return filtered;
 	}
 
 	readPackageScope(path) {
 		while (true) {
-			const dir = this.fs.dirname(path);
+			const dir = this.pathDirname(path);
 			if (dir === path) break;
-			const basename = this.fs.basename(dir);
+			const basename = this.pathBasename(dir);
 			if (basename === 'node_modules') break;
 			const pack = this.readPackage(dir);
 			if (pack) return {data: pack, scope: dir};
@@ -401,7 +400,7 @@ class DefaultResolver extends Resolver {
 		// 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP
 		// 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP
 		// 3. If X/index.node is a file, load X/index.node as binary addon. STOP
-		return this.tryWithExtension(this.fs.join(x, 'index'), extList);
+		return this.tryWithExtension(this.pathConcat(x, 'index'), extList);
 	}
 
 	// LOAD_AS_DIRECTORY(X)
@@ -413,7 +412,7 @@ class DefaultResolver extends Resolver {
 			// b. If "main" is a falsy value, GOTO 2.
 			if (typeof pack.main === 'string') {
 				// c. let M = X + (json main field)
-				const m = this.fs.join(x, pack.main);
+				const m = this.pathConcat(x, pack.main);
 				// d. LOAD_AS_FILE(M)
 				let f = this.loadAsFile(m, extList);
 				if (f) return f;
@@ -508,7 +507,7 @@ class DefaultResolver extends Resolver {
 		// 2. If X does not match this pattern or DIR/NAME/package.json is not a file,
 		//    return.
 		if (!res) return undefined;
-		const scope = this.fs.join(dir, res[1]);
+		const scope = this.pathConcat(dir, res[1]);
 		const pack = this.readPackage(scope);
 		if (!pack) return undefined;
 		// 3. Parse DIR/NAME/package.json, and look for "exports" field.
@@ -708,7 +707,7 @@ class DefaultResolver extends Resolver {
 							return this.packageResolve(target.replace(/\*/g, subpath), packageURL, conditions, extList);
 						}
 						// b. Return PACKAGE_RESOLVE(target + subpath, packageURL + "/").
-						return this.packageResolve(this.fs.join(target, subpath), packageURL, conditions, extList);
+						return this.packageResolve(this.pathConcat(target, subpath), packageURL, conditions, extList);
 					}
 				}
 				// Otherwise, throw an Invalid Package Target error.
@@ -721,7 +720,7 @@ class DefaultResolver extends Resolver {
 				throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');
 			}
 			// d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.
-			const resolvedTarget = this.fs.join(packageURL, target);
+			const resolvedTarget = this.pathConcat(packageURL, target);
 			// e. Assert: resolvedTarget is contained in packageURL.
 			subpath = decodeURI(subpath);
 			// f. If subpath split on "/" or "\" contains any ".", ".." or "node_modules" segments, case insensitive and including percent
@@ -736,7 +735,7 @@ class DefaultResolver extends Resolver {
 			}
 			// h. Otherwise,
 			// 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.
-			return this.fs.join(resolvedTarget, subpath);
+			return this.pathConcat(resolvedTarget, subpath);
 		// 3. Otherwise, if target is an Array, then
 		} else if (Array.isArray(target)) {
 			// a. If target.length is zero, return null.
@@ -807,7 +806,7 @@ class DefaultResolver extends Resolver {
 			throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');
 		}
 		// 3. If packageSpecifier is a Node.js builtin module name, then
-		if (this.builtins.has(packageSpecifier)) {
+		if (this.builtinModules[packageSpecifier]) {
 			// a. Return the string "node:" concatenated with packageSpecifier.
 			return 'node:' + packageSpecifier;
 		}
@@ -846,11 +845,11 @@ class DefaultResolver extends Resolver {
 		let packageURL;
 		while (true) {
 			// a. Let packageURL be the URL resolution of "node_modules/" concatenated with packageSpecifier, relative to parentURL.
-			packageURL = this.fs.resolve(this.fs.join(parentURL, 'node_modules', packageSpecifier));
+			packageURL = this.pathResolve(this.pathConcat(parentURL, 'node_modules', packageSpecifier));
 			// b. Set parentURL to the parent folder URL of parentURL.
-			const parentParentURL = this.fs.dirname(parentURL);
+			const parentParentURL = this.pathDirname(parentURL);
 			// c. If the folder at packageURL does not exist, then
-			if (this.isPathAllowed(packageURL) && pathTestIsDirectory(this.fs, packageURL)) break;
+			if (this.isPathAllowed(packageURL) && this.pathTestIsDirectory(packageURL)) break;
 			// 1. Continue the next loop iteration.
 			if (parentParentURL === parentURL) {
 				// 12. Throw a Module Not Found error.
@@ -873,7 +872,7 @@ class DefaultResolver extends Resolver {
 		}
 		// g. Otherwise,
 		// 1. Return the URL resolution of packageSubpath in packageURL.
-		return this.fs.join(packageURL, packageSubpath);
+		return this.pathConcat(packageURL, packageSubpath);
 	}
 
 }
diff --git a/node_modules/vm2/lib/setup-node-sandbox.js b/node_modules/vm2/lib/setup-node-sandbox.js
index c4fa5cb..05f38ef 100644
--- a/node_modules/vm2/lib/setup-node-sandbox.js
+++ b/node_modules/vm2/lib/setup-node-sandbox.js
@@ -37,23 +37,17 @@ const {
 	argv: optionArgv,
 	env: optionEnv,
 	console: optionConsole,
-	extensions,
-	emitArgs,
-	globalPaths,
-	getLookupPathsFor,
-	resolve: resolve0,
-	lookupPaths,
-	loadBuiltinModule,
-	registerModule,
-	builtinModules,
-	dirname,
-	basename
+	vm,
+	resolver,
+	extensions
 } = data;
 
 function ensureSandboxArray(a) {
 	return localArrayPrototypeSlice(a);
 }
 
+const globalPaths = ensureSandboxArray(resolver.globalPaths);
+
 class Module {
 
 	constructor(id, path, parent) {
@@ -62,7 +56,7 @@ class Module {
 		this.path = path;
 		this.parent = parent;
 		this.loaded = false;
-		this.paths = path ? ensureSandboxArray(getLookupPathsFor(path)) : [];
+		this.paths = path ? ensureSandboxArray(resolver.genLookupPaths(path)) : [];
 		this.children = [];
 		this.exports = {};
 	}
@@ -87,12 +81,12 @@ function requireImpl(mod, id, direct) {
 	if (direct && mod.require !== originalRequire) {
 		return mod.require(id);
 	}
-	const filename = resolve0(mod, id, undefined, Module._extensions, direct);
+	const filename = resolver.resolve(mod, id, undefined, Module._extensions, direct);
 	if (localStringPrototypeStartsWith(filename, 'node:')) {
 		id = localStringPrototypeSlice(filename, 5);
 		let nmod = cacheBuiltins[id];
 		if (!nmod) {
-			nmod = loadBuiltinModule(id);
+			nmod = resolver.loadBuiltinModule(vm, id);
 			if (!nmod) throw new VMError(`Cannot find module '${filename}'`, 'ENOTFOUND');
 			cacheBuiltins[id] = nmod;
 		}
@@ -107,15 +101,15 @@ function requireImpl(mod, id, direct) {
 
 	let nmod = cacheBuiltins[id];
 	if (nmod) return nmod;
-	nmod = loadBuiltinModule(id);
+	nmod = resolver.loadBuiltinModule(vm, id);
 	if (nmod) {
 		cacheBuiltins[id] = nmod;
 		return nmod;
 	}
 
-	const path = dirname(filename);
+	const path = resolver.fs.dirname(filename);
 	const module = new Module(filename, path, mod);
-	registerModule(module, filename, path, mod, direct);
+	resolver.registerModule(module, filename, path, mod, direct);
 	mod._updateChildren(module, true);
 	try {
 		Module._cache[filename] = module;
@@ -137,8 +131,8 @@ function requireImpl(mod, id, direct) {
 	return module.exports;
 }
 
-Module.builtinModules = ensureSandboxArray(builtinModules);
-Module.globalPaths = ensureSandboxArray(globalPaths);
+Module.builtinModules = ensureSandboxArray(resolver.getBuiltinModulesList());
+Module.globalPaths = globalPaths;
 Module._extensions = {__proto__: null};
 Module._cache = {__proto__: null};
 
@@ -152,7 +146,7 @@ Module._cache = {__proto__: null};
 }
 
 function findBestExtensionHandler(filename) {
-	const name = basename(filename);
+	const name = resolver.fs.basename(filename);
 	for (let i = 0; (i = localStringPrototypeIndexOf(name, '.', i + 1)) !== -1;) {
 		const ext = localStringPrototypeSlice(name, i);
 		const handler = Module._extensions[ext];
@@ -171,11 +165,11 @@ function createRequireForModule(mod) {
 		return requireImpl(mod, id, true);
 	}
 	function resolve(id, options) {
-		return resolve0(mod, id, options, Module._extensions, true);
+		return resolver.resolve(mod, id, options, Module._extensions, true);
 	}
 	require.resolve = resolve;
 	function paths(id) {
-		return ensureSandboxArray(lookupPaths(mod, id));
+		return ensureSandboxArray(resolver.lookupPaths(mod, id));
 	}
 	resolve.paths = paths;
 
@@ -283,6 +277,20 @@ global.clearImmediate = function clearImmediate(immediate) {
 
 const localProcess = host.process;
 
+function vmEmitArgs(event, args) {
+	const allargs = [event];
+	for (let i = 0; i < args.length; i++) {
+		if (!localReflectDefineProperty(allargs, i + 1, {
+			__proto__: null,
+			value: args[i],
+			writable: true,
+			enumerable: true,
+			configurable: true
+		})) throw new LocalError('Unexpected');
+	}
+	return localReflectApply(vm.emit, vm, allargs);
+}
+
 const LISTENERS = new LocalWeakMap();
 const LISTENER_HANDLER = new LocalWeakMap();
 
@@ -427,27 +435,27 @@ if (optionConsole === 'inherit') {
 } else if (optionConsole === 'redirect') {
 	global.console = {
 		debug(...args) {
-			emitArgs('console.debug', args);
+			vmEmitArgs('console.debug', args);
 		},
 		log(...args) {
-			emitArgs('console.log', args);
+			vmEmitArgs('console.log', args);
 		},
 		info(...args) {
-			emitArgs('console.info', args);
+			vmEmitArgs('console.info', args);
 		},
 		warn(...args) {
-			emitArgs('console.warn', args);
+			vmEmitArgs('console.warn', args);
 		},
 		error(...args) {
-			emitArgs('console.error', args);
+			vmEmitArgs('console.error', args);
 		},
 		dir(...args) {
-			emitArgs('console.dir', args);
+			vmEmitArgs('console.dir', args);
 		},
 		time() {},
 		timeEnd() {},
 		trace(...args) {
-			emitArgs('console.trace', args);
+			vmEmitArgs('console.trace', args);
 		}
 	};
 }
diff --git a/node_modules/vm2/lib/setup-sandbox.js b/node_modules/vm2/lib/setup-sandbox.js
index fbfacc4..71afa52 100644
--- a/node_modules/vm2/lib/setup-sandbox.js
+++ b/node_modules/vm2/lib/setup-sandbox.js
@@ -21,7 +21,6 @@ const {
 const {
 	getPrototypeOf: localReflectGetPrototypeOf,
 	apply: localReflectApply,
-	construct: localReflectConstruct,
 	deleteProperty: localReflectDeleteProperty,
 	has: localReflectHas,
 	defineProperty: localReflectDefineProperty,
@@ -433,63 +432,6 @@ if (AsyncGeneratorFunction) {
 	overrideWithProxy(AsyncGeneratorFunction.prototype, 'constructor', AsyncGeneratorFunction, makeCheckFunction(true, true));
 }
 
-function makeSafeHandlerArgs(args) {
-	const sArgs = ensureThis(args);
-	if (sArgs === args) return args;
-	const a = [];
-	for (let i=0; i < sArgs.length; i++) {
-		localReflectDefineProperty(a, i, {
-			__proto__: null,
-			value: sArgs[i],
-			enumerable: true,
-			configurable: true,
-			writable: true
-		});
-	}
-	return a;
-}
-
-const makeSafeArgs = Object.freeze({
-	__proto__: null,
-	apply(target, thiz, args) {
-		return localReflectApply(target, thiz, makeSafeHandlerArgs(args));
-	},
-	construct(target, args, newTarget) {
-		return localReflectConstruct(target, makeSafeHandlerArgs(args), newTarget);
-	}
-});
-
-const proxyHandlerHandler = Object.freeze({
-	__proto__: null,
-	get(target, name, receiver) {
-		const value = target.handler[name];
-		if (typeof value !== 'function') return value;
-		return new LocalProxy(value, makeSafeArgs);
-	}
-});
-
-function wrapProxyHandler(args) {
-	if (args.length < 2) return args;
-	const handler = args[1];
-	args[1] = new LocalProxy({__proto__: null, handler}, proxyHandlerHandler);
-	return args;
-}
-
-const proxyHandler = Object.freeze({
-	__proto__: null,
-	apply(target, thiz, args) {
-		return localReflectApply(target, thiz, wrapProxyHandler(args));
-	},
-	construct(target, args, newTarget) {
-		return localReflectConstruct(target, wrapProxyHandler(args), newTarget);
-	}
-});
-
-const proxiedProxy = new LocalProxy(LocalProxy, proxyHandler);
-
-overrideWithProxy(LocalProxy, 'revocable', LocalProxy.revocable, proxyHandler);
-
-global.Proxy = proxiedProxy;
 global.Function = proxiedFunction;
 global.eval = new LocalProxy(localEval, EvalHandler);
 
diff --git a/node_modules/vm2/lib/vm.js b/node_modules/vm2/lib/vm.js
index 0b71f0b..d1a1e57 100644
--- a/node_modules/vm2/lib/vm.js
+++ b/node_modules/vm2/lib/vm.js
@@ -44,9 +44,6 @@ const {
 const {
 	VMScript
 } = require('./script');
-const {
-	inspect
-} = require('util');
 
 const objectDefineProperties = Object.defineProperties;
 
@@ -142,10 +139,10 @@ function doWithTimeout(fn, timeout) {
 	}
 }
 
-const bridgeScript = compileScript(`${__dirname}/bridge.js`,
-	`(function(global) {"use strict"; const exports = {};${fs.readFileSync(`${__dirname}/bridge.js`, 'utf8')}\nreturn exports;})`);
-const setupSandboxScript = compileScript(`${__dirname}/setup-sandbox.js`,
-	`(function(global, host, bridge, data, context) { ${fs.readFileSync(`${__dirname}/setup-sandbox.js`, 'utf8')}\n})`);
+const bridgeScript = compileScript(`${__dirname}/${VM2_LIB_PATH || ''}bridge.js`,
+	`(function(global) {"use strict"; const exports = {};${fs.readFileSync(`${__dirname}/${VM2_LIB_PATH || ''}bridge.js`, 'utf8')}\nreturn exports;})`);
+const setupSandboxScript = compileScript(`${__dirname}/${VM2_LIB_PATH || ''}setup-sandbox.js`,
+	`(function(global, host, bridge, data, context) { ${fs.readFileSync(`${__dirname}/${VM2_LIB_PATH || ''}setup-sandbox.js`, 'utf8')}\n})`);
 const getGlobalScript = compileScript('get_global.js', 'this');
 
 let getGeneratorFunctionScript = null;
@@ -368,8 +365,6 @@ class VM extends EventEmitter {
 			_allowAsync: {__proto__: null, value: allowAsync}
 		});
 
-		this.readonly(inspect);
-
 		// prepare global sandbox
 		if (sandbox) {
 			this.setGlobals(sandbox);
